{"version":3,"sources":["./node_modules/ngx-cacheable/cache-buster.decorator.js","./node_modules/ngx-cacheable/cacheable.decorator.js","./node_modules/ngx-cacheable/common/IStorageStrategy.js","./node_modules/ngx-cacheable/common/InMemoryStorageStrategy.js","./node_modules/ngx-cacheable/common/index.js","./node_modules/ngx-cacheable/index.js","./node_modules/ngx-cacheable/promise.cache-buster.decorator.js","./node_modules/ngx-cacheable/promise.cacheable.decorator.js","./src/app/views/main/list/list.component.html","./src/app/views/main/list/list.component.ts","./src/app/views/main/list/list.module.ts"],"names":[],"mappings":";;;;;;;;;;AAAa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,uEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,mDAAM;AAC3B,kBAAkB,mBAAO,CAAC,uEAAgB;AAC1C,eAAe,mBAAO,CAAC,8DAAU;AACjC;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,mEAAmE,wEAAwE,EAAE;AAC7I;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACzHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;ACRa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,mFAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mD;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,mFAAoB;AACrD;AACA,gCAAgC,mBAAO,CAAC,iGAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACba;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,wFAA0B;AAC3C,SAAS,mBAAO,CAAC,kFAAuB;AACxC,SAAS,mBAAO,CAAC,wGAAkC;AACnD,SAAS,mBAAO,CAAC,kGAA+B;AAChD,SAAS,mBAAO,CAAC,8DAAU;AAC3B,SAAS,mBAAO,CAAC,wGAAkC;AACnD,iC;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,mDAAM;AAC3B,eAAe,mBAAO,CAAC,8DAAU;AACjC;AACA;AACA,uDAAuD,wEAAwE,EAAE;AACjI;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,qJAAqJ,EAAE;AACzN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACxIA;AAAe,mqBAAomB,YAAY,oDAAoD,cAAc,oDAAoD,kBAAkB,oDAAoD,eAAe,oDAAoD,uBAAuB,uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAn2B;AACR;AACA;AAG1C,IAAa,gBAAgB,GAA7B,MAAa,gBAAgB;IAGzB,YAA6B,IAAgB;QAAhB,SAAI,GAAJ,IAAI,CAAY;QACzC,IAAI,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC,IAAS,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;IAC1D,CAAC;IAGD,GAAG;QACC,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,4CAA4C,CAAC,CAAC;IACvE,CAAC;CACJ;;YARsC,+DAAU;;AAK7C;IADC,+DAAS,EAAE;;;;2CAGX;AAVQ,gBAAgB;IAD5B,+DAAS,CAAC,EAAE,QAAQ,EAAE,UAAU,EAAE,qLAAoC,EAAE,CAAC;qCAInC,+DAAU;GAHpC,gBAAgB,CAW5B;AAX4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLkB;AACN;AACc;AACH;AAEpD,MAAM,MAAM,GAAW;IACnB,EAAE,IAAI,EAAE,EAAE,EAAE,SAAS,EAAE,gEAAgB,EAAE;CAC5C,CAAC;AASF,IAAa,aAAa,GAA1B,MAAa,aAAa;CAAI;AAAjB,aAAa;IAPzB,8DAAQ,CAAC;QACN,YAAY,EAAE,CAAC,gEAAgB,CAAC;QAChC,OAAO,EAAE;YACL,4DAAY;YACZ,4DAAY,CAAC,QAAQ,CAAC,MAAM,CAAC;SAChC;KACJ,CAAC;GACW,aAAa,CAAI;AAAJ","file":"views-main-list-list-module-es2015.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\nfunction CacheBuster(cacheBusterConfig) {\n    return function (_target, _propertyKey, propertyDescriptor) {\n        var oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function () {\n                var parameters = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    parameters[_i] = arguments[_i];\n                }\n                return oldMethod.call.apply(oldMethod, [this].concat(parameters)).pipe(operators_1.tap(function () {\n                    if (cacheBusterConfig.cacheBusterNotifier) {\n                        cacheBusterConfig.cacheBusterNotifier.next();\n                    }\n                }));\n            };\n        }\n        ;\n        return propertyDescriptor;\n    };\n}\nexports.CacheBuster = CacheBuster;\n;\n//# sourceMappingURL=cache-buster.decorator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\nvar common_1 = require(\"./common\");\nexports.globalCacheBusterNotifier = new rxjs_1.Subject();\nfunction Cacheable(cacheConfig) {\n    if (cacheConfig === void 0) { cacheConfig = {}; }\n    return function (_target, _propertyKey, propertyDescriptor) {\n        var cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n        var oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            var storageStrategy_1 = !cacheConfig.storageStrategy\n                ? new common_1.GlobalCacheConfig.storageStrategy()\n                : new cacheConfig.storageStrategy();\n            var pendingCachePairs_1 = [];\n            /**\n             * subscribe to the globalCacheBuster\n             * if a custom cacheBusterObserver is passed, subscribe to it as well\n             * subscribe to the cacheBusterObserver and upon emission, clear all caches\n             */\n            rxjs_1.merge(exports.globalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver\n                ? cacheConfig.cacheBusterObserver\n                : rxjs_1.empty()).subscribe(function (_) {\n                storageStrategy_1.removeAll(cacheKey);\n                pendingCachePairs_1.length = 0;\n            });\n            cacheConfig.cacheResolver = cacheConfig.cacheResolver\n                ? cacheConfig.cacheResolver\n                : common_1.DEFAULT_CACHE_RESOLVER;\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function () {\n                var _parameters = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    _parameters[_i] = arguments[_i];\n                }\n                var cachePairs = storageStrategy_1.getAll(cacheKey);\n                var parameters = _parameters.map(function (param) { return param !== undefined ? JSON.parse(JSON.stringify(param)) : param; });\n                var _foundCachePair = cachePairs.find(function (cp) {\n                    return cacheConfig.cacheResolver(cp.parameters, parameters);\n                });\n                var _foundPendingCachePair = pendingCachePairs_1.find(function (cp) {\n                    return cacheConfig.cacheResolver(cp.parameters, parameters);\n                });\n                /**\n                 * check if maxAge is passed and cache has actually expired\n                 */\n                if (cacheConfig.maxAge && _foundCachePair && _foundCachePair.created) {\n                    if (new Date().getTime() - new Date(_foundCachePair.created).getTime() >\n                        cacheConfig.maxAge) {\n                        /**\n                         * cache duration has expired - remove it from the cachePairs array\n                         */\n                        storageStrategy_1.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey);\n                        _foundCachePair = null;\n                    }\n                    else if (cacheConfig.slidingExpiration) {\n                        /**\n                         * renew cache duration\n                         */\n                        _foundCachePair.created = new Date();\n                        storageStrategy_1.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey);\n                    }\n                }\n                if (_foundCachePair) {\n                    var cached$ = rxjs_1.of(_foundCachePair.response);\n                    return cacheConfig.async ? cached$.pipe(operators_1.delay(0)) : cached$;\n                }\n                else if (_foundPendingCachePair) {\n                    return _foundPendingCachePair.response;\n                }\n                else {\n                    var response$ = oldMethod.call.apply(oldMethod, [this].concat(parameters)).pipe(operators_1.finalize(function () {\n                        /**\n                         * if there has been an observable cache pair for these parameters, when it completes or errors, remove it\n                         */\n                        var _pendingCachePairToRemove = pendingCachePairs_1.find(function (cp) {\n                            return cacheConfig.cacheResolver(cp.parameters, parameters);\n                        });\n                        pendingCachePairs_1.splice(pendingCachePairs_1.indexOf(_pendingCachePairToRemove), 1);\n                    }), operators_1.tap(function (response) {\n                        /**\n                         * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n                         * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n                         */\n                        if (!cacheConfig.shouldCacheDecider ||\n                            cacheConfig.shouldCacheDecider(response)) {\n                            if (!cacheConfig.maxCacheCount ||\n                                cacheConfig.maxCacheCount === 1 ||\n                                (cacheConfig.maxCacheCount &&\n                                    cacheConfig.maxCacheCount < cachePairs.length + 1)) {\n                                storageStrategy_1.removeAtIndex(0, cacheKey);\n                            }\n                            storageStrategy_1.add({\n                                parameters: parameters,\n                                response: response,\n                                created: cacheConfig.maxAge ? new Date() : null\n                            }, cacheKey);\n                        }\n                    }), \n                    /**\n                     * replay cached observable, so we don't enter finalize and tap for every cached observable subscription\n                     */\n                    operators_1.shareReplay());\n                    /**\n                     * cache the stream\n                     */\n                    pendingCachePairs_1.push({\n                        parameters: parameters,\n                        response: response$,\n                        created: new Date()\n                    });\n                    return response$;\n                }\n            };\n        }\n        return propertyDescriptor;\n    };\n}\nexports.Cacheable = Cacheable;\n;\n//# sourceMappingURL=cacheable.decorator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IStorageStrategy = /** @class */ (function () {\n    function IStorageStrategy() {\n    }\n    return IStorageStrategy;\n}());\nexports.IStorageStrategy = IStorageStrategy;\n//# sourceMappingURL=IStorageStrategy.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IStorageStrategy_1 = require(\"./IStorageStrategy\");\nvar InMemoryStorageStrategy = /** @class */ (function (_super) {\n    __extends(InMemoryStorageStrategy, _super);\n    function InMemoryStorageStrategy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.cachePairs = [];\n        return _this;\n    }\n    InMemoryStorageStrategy.prototype.add = function (cachePair) {\n        this.cachePairs.push(cachePair);\n    };\n    ;\n    InMemoryStorageStrategy.prototype.updateAtIndex = function (index, entity) {\n        var updatee = this.cachePairs[index];\n        Object.assign(updatee, entity);\n    };\n    InMemoryStorageStrategy.prototype.getAll = function () {\n        return this.cachePairs;\n    };\n    ;\n    InMemoryStorageStrategy.prototype.removeAtIndex = function (index) {\n        this.cachePairs.splice(index, 1);\n    };\n    InMemoryStorageStrategy.prototype.removeAll = function () {\n        this.cachePairs.length = 0;\n    };\n    return InMemoryStorageStrategy;\n}(IStorageStrategy_1.IStorageStrategy));\nexports.InMemoryStorageStrategy = InMemoryStorageStrategy;\n//# sourceMappingURL=InMemoryStorageStrategy.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IStorageStrategy_1 = require(\"./IStorageStrategy\");\nexports.IStorageStrategy = IStorageStrategy_1.IStorageStrategy;\nvar InMemoryStorageStrategy_1 = require(\"./InMemoryStorageStrategy\");\nexports.DEFAULT_CACHE_RESOLVER = function (oldParams, newParams) {\n    return JSON.stringify(oldParams) === JSON.stringify(newParams);\n};\nexports.GlobalCacheConfig = {\n    storageStrategy: InMemoryStorageStrategy_1.InMemoryStorageStrategy,\n    globalCacheKey: 'CACHE_STORAGE',\n    promiseImplementation: Promise\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./cache-buster.decorator\"));\n__export(require(\"./cacheable.decorator\"));\n__export(require(\"./promise.cache-buster.decorator\"));\n__export(require(\"./promise.cacheable.decorator\"));\n__export(require(\"./common\"));\n__export(require(\"./common/InMemoryStorageStrategy\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction PCacheBuster(cacheBusterConfig) {\n    return function (_target, _propertyKey, propertyDescriptor) {\n        var oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function () {\n                var parameters = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    parameters[_i] = arguments[_i];\n                }\n                return oldMethod.call.apply(oldMethod, [this].concat(parameters)).then(function (response) {\n                    if (cacheBusterConfig.cacheBusterNotifier) {\n                        cacheBusterConfig.cacheBusterNotifier.next();\n                    }\n                    return response;\n                });\n            };\n        }\n        ;\n        return propertyDescriptor;\n    };\n}\nexports.PCacheBuster = PCacheBuster;\n;\n//# sourceMappingURL=promise.cache-buster.decorator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar common_1 = require(\"./common\");\nexports.promiseGlobalCacheBusterNotifier = new rxjs_1.Subject();\nvar getResponse = function (oldMethod, cacheKey, cacheConfig, context, cachePairs, _parameters, pendingCachePairs, storageStrategy, promiseImplementation) {\n    var parameters = _parameters.map(function (param) { return param !== undefined ? JSON.parse(JSON.stringify(param)) : param; });\n    var _foundCachePair = cachePairs.find(function (cp) {\n        return cacheConfig.cacheResolver(cp.parameters, parameters);\n    });\n    var _foundPendingCachePair = pendingCachePairs.find(function (cp) {\n        return cacheConfig.cacheResolver(cp.parameters, parameters);\n    });\n    /**\n     * check if maxAge is passed and cache has actually expired\n     */\n    if (cacheConfig.maxAge && _foundCachePair && _foundCachePair.created) {\n        if (new Date().getTime() - new Date(_foundCachePair.created).getTime() >\n            cacheConfig.maxAge) {\n            /**\n             * cache duration has expired - remove it from the cachePairs array\n             */\n            storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey);\n            _foundCachePair = null;\n        }\n        else if (cacheConfig.slidingExpiration) {\n            /**\n             * renew cache duration\n             */\n            _foundCachePair.created = new Date();\n            storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey);\n        }\n    }\n    if (_foundCachePair) {\n        return promiseImplementation.resolve(_foundCachePair.response);\n    }\n    else if (_foundPendingCachePair) {\n        return _foundPendingCachePair.response;\n    }\n    else {\n        var response$ = oldMethod.call.apply(oldMethod, [context].concat(parameters))\n            .then(function (response) {\n            removeCachePair(pendingCachePairs, parameters, cacheConfig);\n            /**\n             * if no maxCacheCount has been passed\n             * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n             * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n             */\n            if (!cacheConfig.shouldCacheDecider ||\n                cacheConfig.shouldCacheDecider(response)) {\n                if (!cacheConfig.maxCacheCount ||\n                    cacheConfig.maxCacheCount === 1 ||\n                    (cacheConfig.maxCacheCount &&\n                        cacheConfig.maxCacheCount < cachePairs.length + 1)) {\n                    storageStrategy.removeAtIndex(0, cacheKey);\n                }\n                storageStrategy.add({\n                    parameters: parameters,\n                    response: response,\n                    created: cacheConfig.maxAge ? new Date() : null\n                }, cacheKey);\n            }\n            return response;\n        })\n            .catch(function (error) {\n            removeCachePair(pendingCachePairs, parameters, cacheConfig);\n            return promiseImplementation.reject(error);\n        });\n        /**\n         * cache the stream\n         */\n        pendingCachePairs.push({\n            parameters: parameters,\n            response: response$,\n            created: new Date()\n        });\n        return response$;\n    }\n};\nvar removeCachePair = function (cachePairs, parameters, cacheConfig) {\n    /**\n     * if there has been an pending cache pair for these parameters, when it completes or errors, remove it\n     */\n    var _pendingCachePairToRemove = cachePairs.find(function (cp) {\n        return cacheConfig.cacheResolver(cp.parameters, parameters);\n    });\n    cachePairs.splice(cachePairs.indexOf(_pendingCachePairToRemove), 1);\n};\nfunction PCacheable(cacheConfig) {\n    if (cacheConfig === void 0) { cacheConfig = {}; }\n    return function (_target, _propertyKey, propertyDescriptor) {\n        var cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n        var oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            var storageStrategy_1 = !cacheConfig.storageStrategy\n                ? new common_1.GlobalCacheConfig.storageStrategy()\n                : new cacheConfig.storageStrategy();\n            var pendingCachePairs_1 = [];\n            /**\n             * subscribe to the promiseGlobalCacheBusterNotifier\n             * if a custom cacheBusterObserver is passed, subscribe to it as well\n             * subscribe to the cacheBusterObserver and upon emission, clear all caches\n             */\n            rxjs_1.merge(exports.promiseGlobalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver\n                ? cacheConfig.cacheBusterObserver\n                : rxjs_1.empty()).subscribe(function (_) {\n                storageStrategy_1.removeAll(cacheKey);\n                pendingCachePairs_1.length = 0;\n            });\n            cacheConfig.cacheResolver = cacheConfig.cacheResolver\n                ? cacheConfig.cacheResolver\n                : common_1.DEFAULT_CACHE_RESOLVER;\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function () {\n                var _this = this;\n                var _parameters = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    _parameters[_i] = arguments[_i];\n                }\n                var promiseImplementation = typeof common_1.GlobalCacheConfig.promiseImplementation === 'function' && (common_1.GlobalCacheConfig.promiseImplementation !== Promise) ?\n                    common_1.GlobalCacheConfig.promiseImplementation.call(this)\n                    : common_1.GlobalCacheConfig.promiseImplementation;\n                var cachePairs = storageStrategy_1.getAll(cacheKey);\n                if (!(cachePairs instanceof promiseImplementation)) {\n                    return getResponse(oldMethod, cacheKey, cacheConfig, this, cachePairs, _parameters, pendingCachePairs_1, storageStrategy_1, promiseImplementation);\n                }\n                else {\n                    return cachePairs.then(function (cachePairs) { return getResponse(oldMethod, cacheKey, cacheConfig, _this, cachePairs, _parameters, pendingCachePairs_1, storageStrategy_1, promiseImplementation); });\n                }\n            };\n        }\n        return propertyDescriptor;\n    };\n}\nexports.PCacheable = PCacheable;\n;\n//# sourceMappingURL=promise.cacheable.decorator.js.map","export default \"<h2>List</h2>\\r\\n\\r\\n<table class=\\\"uk-table uk-table-responsive uk-table-divider uk-table-hover uk-table-small uk-table-striped\\\">\\r\\n    <thead>\\r\\n        <tr>\\r\\n            <th class=\\\"uk-text-nowrap uk-text-center@m\\\">Id</th>\\r\\n            <th class=\\\"uk-text-nowrap\\\">Name</th>\\r\\n            <th class=\\\"uk-text-nowrap\\\">Username</th>\\r\\n            <th class=\\\"uk-text-nowrap\\\">Email</th>\\r\\n            <th class=\\\"uk-text-nowrap\\\">Company</th>\\r\\n        </tr>\\r\\n    </thead>\\r\\n    <tbody>\\r\\n        <tr *ngFor=\\\"let item of list\\\">\\r\\n            <td class=\\\"uk-text-nowrap uk-text-center@m\\\">{{ item?.id }}</td>\\r\\n            <td class=\\\"uk-text-nowrap\\\">{{ item?.name }}</td>\\r\\n            <td class=\\\"uk-text-nowrap\\\">{{ item?.username }}</td>\\r\\n            <td class=\\\"uk-text-nowrap\\\">{{ item?.email }}</td>\\r\\n            <td class=\\\"uk-text-nowrap\\\">{{ item?.company?.name }}</td>\\r\\n        </tr>\\r\\n    </tbody>\\r\\n</table>\\r\\n\"","import { HttpClient } from \"@angular/common/http\";\r\nimport { Component } from \"@angular/core\";\r\nimport { Cacheable } from \"ngx-cacheable\";\r\n\r\n@Component({ selector: \"app-list\", templateUrl: \"./list.component.html\" })\r\nexport class AppListComponent {\r\n    list: any;\r\n\r\n    constructor(private readonly http: HttpClient) {\r\n        this.get().subscribe((list: any) => this.list = list);\r\n    }\r\n\r\n    @Cacheable()\r\n    get() {\r\n        return this.http.get(\"https://jsonplaceholder.typicode.com/users\");\r\n    }\r\n}\r\n","import { CommonModule } from \"@angular/common\";\r\nimport { NgModule } from \"@angular/core\";\r\nimport { RouterModule, Routes } from \"@angular/router\";\r\nimport { AppListComponent } from \"./list.component\";\r\n\r\nconst routes: Routes = [\r\n    { path: \"\", component: AppListComponent }\r\n];\r\n\r\n@NgModule({\r\n    declarations: [AppListComponent],\r\n    imports: [\r\n        CommonModule,\r\n        RouterModule.forChild(routes)\r\n    ]\r\n})\r\nexport class AppListModule { }\r\n"],"sourceRoot":"webpack:///"}